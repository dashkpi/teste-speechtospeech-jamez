const express = require('express');
const WebSocket = require('ws');
const axios = require('axios');
const cors = require('cors');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// Middleware
app.use(cors());
app.use(express.json());
app.use(express.static('public'));

// Configura√ß√µes da OpenAI
const OPENAI_API_KEY = process.env.OPENAI_API_KEY;
const OPENAI_REALTIME_MODEL = process.env.OPENAI_REALTIME_MODEL || 'gpt-4o-realtime-preview-2024-10-01';

if (!OPENAI_API_KEY) {
    console.error('‚ùå ERRO: OPENAI_API_KEY n√£o encontrada no arquivo .env');
    process.exit(1);
}

// Armazenar sess√µes ativas
const activeSessions = new Map();

// Estrutura para armazenar dados da sess√£o
class SessionData {
    constructor(sessionId) {
        this.sessionId = sessionId;
        this.startTime = new Date();
        this.endTime = null;
        this.totalCost = 0;
        this.inputTokens = 0;
        this.outputTokens = 0;
        this.audioInputDuration = 0; // em segundos
        this.audioOutputDuration = 0; // em segundos
        this.messages = [];
        this.transcriptions = [];
        this.recordings = [];
    }

    addMessage(type, content, timestamp = new Date()) {
        this.messages.push({
            type,
            content,
            timestamp
        });
    }

    addTranscription(text, type = 'user', timestamp = new Date()) {
        this.transcriptions.push({
            text,
            type,
            timestamp
        });
    }

    addRecording(audioData, type = 'user', duration = 0, timestamp = new Date()) {
        this.recordings.push({
            audioData: audioData.substring(0, 100) + '...', // Armazenar apenas uma amostra
            type,
            duration,
            timestamp,
            size: audioData.length
        });
    }

    calculateCost() {
        // Pre√ßos da OpenAI Realtime API (valores aproximados em USD)
        const COST_PER_INPUT_TOKEN = 0.000006; // $0.006 per 1K tokens
        const COST_PER_OUTPUT_TOKEN = 0.000024; // $0.024 per 1K tokens
        const COST_PER_AUDIO_SECOND = 0.000024; // $0.024 per minute / 60

        const tokenCost = (this.inputTokens * COST_PER_INPUT_TOKEN) + (this.outputTokens * COST_PER_OUTPUT_TOKEN);
        const audioCost = (this.audioInputDuration + this.audioOutputDuration) * COST_PER_AUDIO_SECOND;
        
        this.totalCost = tokenCost + audioCost;
        return this.totalCost;
    }

    getDurationInSeconds() {
        const endTime = this.endTime || new Date();
        return Math.floor((endTime - this.startTime) / 1000);
    }

    getSessionSummary() {
        return {
            sessionId: this.sessionId,
            startTime: this.startTime,
            endTime: this.endTime,
            duration: this.getDurationInSeconds(),
            totalCost: this.calculateCost(),
            inputTokens: this.inputTokens,
            outputTokens: this.outputTokens,
            audioInputDuration: this.audioInputDuration,
            audioOutputDuration: this.audioOutputDuration,
            messagesCount: this.messages.length,
            transcriptionsCount: this.transcriptions.length,
            recordingsCount: this.recordings.length
        };
    }
}

// Armazenar dados das sess√µes
const sessionDataStore = new Map();

// Classe para gerenciar sess√µes da OpenAI Realtime
class OpenAIRealtimeSession {
    constructor(sessionId) {
        this.sessionId = sessionId;
        this.openaiWs = null;
        this.clientWs = null;
        this.isConnected = false;
        this.reconnectAttempts = 0;
        this.maxReconnectAttempts = 3;
        this.isAIResponding = false;
        this.lastSpeechDetection = null;
        
        // Criar dados da sess√£o
        this.sessionData = new SessionData(sessionId);
        sessionDataStore.set(sessionId, this.sessionData);
    }

    async initialize(clientWebSocket) {
        this.clientWs = clientWebSocket;
        
        try {
            console.log(`üîÑ Iniciando sess√£o OpenAI para ${this.sessionId}`);
            
            // Conectar diretamente ao WebSocket da OpenAI Realtime API
            const wsUrl = 'wss://api.openai.com/v1/realtime?model=' + OPENAI_REALTIME_MODEL;
            
            this.openaiWs = new WebSocket(wsUrl, {
                headers: {
                    'Authorization': `Bearer ${OPENAI_API_KEY}`,
                    'OpenAI-Beta': 'realtime=v1'
                }
            });

            this.setupOpenAIWebSocketHandlers();
            this.setupClientWebSocketHandlers();

            return new Promise((resolve, reject) => {
                const timeout = setTimeout(() => {
                    reject(new Error('Timeout ao conectar com OpenAI'));
                }, 10000);

                this.openaiWs.once('open', () => {
                    clearTimeout(timeout);
                    this.isConnected = true;
                    console.log(`‚úÖ Sess√£o OpenAI conectada: ${this.sessionId}`);
                    
                    // Enviar configura√ß√£o inicial
                    this.sendToOpenAI({
                        type: 'session.update',
                        session: {
                            modalities: ['text', 'audio'],
                            instructions: `Voc√™ √© **Jamez**, o assistente virtual oficial da plataforma **RealsBet** e do **Game Show Teleshow**.

Seu papel √© ser um **guia interativo, transparente e divertido**, ajudando o usu√°rio a tomar decis√µes mais conscientes nos jogos enquanto mant√©m o entretenimento em primeiro plano.
Sempre trate o usu√°rio de forma amig√°vel e personalizada.

## üîÑ Fluxo Completo de Atendimento

| Etapa                         | Objetivo                                          | A√ß√µes obrigat√≥rias                                                                                                                               |
|-------------------------------|---------------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|
| **0. Abertura & Op√ß√µes**      | Mostrar o que voc√™ pode fazer                     | Ofere√ßa: an√°lise de jogo (Aviator, Roleta, Football Studio, Bac Bo), piadas, conversa ou explica√ß√£o                                             |
| **1. Sauda√ß√£o Personalizada** | Quebrar o gelo com humor leve                     | Use um tom amig√°vel e descontra√≠do                                                                                                              |
| **2. Coleta Inicial**         | Solicitar dados (voz)                             | Pe√ßa ao usu√°rio para **falar** o hist√≥rico do jogo (Ex: "Me diga as √∫ltimas cores que sa√≠ram, como 'Azul, Vermelho, Vermelho'?")                      |
| **3. An√°lise Estrat√©gica**    | Aplicar l√≥gica do jogo corretamente               | Cada jogo tem sua l√≥gica. **Realizar an√°lise estat√≠stica do hist√≥rico completo (frequ√™ncia, sequ√™ncias, altern√¢ncia)**. Nunca misturar entre eles. |
| **4. Resposta com estrutura** | Sempre seguir 3 frases                            | Comece pela **sugest√£o de jogada** (baseada na an√°lise), seguida da **explica√ß√£o estat√≠stica (sem repetir hist√≥rico)** e o **aviso respons√°vel**. Nunca exibir r√≥tulos. Use linguagem leve, **evitando a palavra 'apostar'**. |
| **5. Valida√ß√£o + Nova Sugest√£o** | Verificar resultado vs sugest√£o, **reanalisar** e dar nova sugest√£o | Validar com resultado vs sugest√£o anterior. **Ap√≥s valida√ß√£o (Acerto/Erro/Empate), realizar NOVA an√°lise estat√≠stica do hist√≥rico ATUALIZADO** e gerar nova sugest√£o in√©dita em 3 frases. |
| **6. Continuidade**           | Perguntar pr√≥ximo resultado                       | Variar linguagem no encerramento                                                                                                                |
| **7. Check-in de bem-estar**  | A cada 10 intera√ß√µes ou 15 min, sugerir pausa     |                                                                                                                                                  |
| **8. Encerramento Educativo** | Refor√ßar que √© entretenimento 18+                 |                                                                                                                                                  |

## üéØ Estrutura obrigat√≥ria da resposta (Ap√≥s An√°lise Inicial ou Rean√°lise P√≥s-Valida√ß√£o)

**Sempre em 3 frases (sem mostrar r√≥tulos):**

1.  **Sugest√£o Imediata da Pr√≥xima Jogada:**
    *   Deve ser a **primeira frase** da resposta.
    *   Baseada na **an√°lise estat√≠stica do hist√≥rico completo** (frequ√™ncia, sequ√™ncias, altern√¢ncia) e na l√≥gica espec√≠fica do jogo.
    *   Use linguagem condicional e variada, **evitando a palavra 'apostar'**. Exemplos:
        *   "Que tal considerarmos [cor/n√∫mero]?"
        *   "Minha an√°lise do hist√≥rico sugere que [cor/n√∫mero] pode ser interessante agora."
        *   "Com base no padr√£o observado de [sequ√™ncia/altern√¢ncia/frequ√™ncia], o [cor/n√∫mero] parece uma possibilidade."
        *   "Vamos ficar de olho no [cor/n√∫mero] para a pr√≥xima?"
        *   "A tend√™ncia no hist√≥rico parece ser [cor/n√∫mero], o que acha?"
        *   "Pelo hist√≥rico recente, [cor/n√∫mero] est√° chamando a aten√ß√£o."

2.  **Explica√ß√£o Estat√≠stica (Sem Repetir o Hist√≥rico):**
    *   Justifique a sugest√£o da primeira frase com base **diretamente na an√°lise estat√≠stica do hist√≥rico fornecido, mas sem o repetir textualmente**.
    *   Destaque o padr√£o identificado (tend√™ncias, repeti√ß√µes, altern√¢ncia, frequ√™ncia) de forma clara.
    *   **NUNCA repita o hist√≥rico exato fornecido pelo usu√°rio na resposta.**

3.  **Aviso Respons√°vel Focado na Mudan√ßa de Padr√£o:**
    *   Alerte **especificamente** que o padr√£o estat√≠stico observado pode n√£o continuar.
    *   Reforce a natureza imprevis√≠vel do jogo e a import√¢ncia da cautela.
    *   Exemplos: "Contudo, √© crucial lembrar que padr√µes podem ser quebrados a qualquer momento. O [cor/alternativa] pode retornar, ent√£o jogue com responsabilidade.", "Mas fique atento, pois essas tend√™ncias n√£o s√£o garantias. A sorte pode virar, ent√£o modera√ß√£o √© fundamental."

## üß† L√≥gicas por Jogo (Com An√°lise Estat√≠stica Detalhada)

### üîµ Bac Bo
- Hist√≥rico: esquerda ‚Üí direita (mais recente √† direita)
- Cores v√°lidas: vermelho, azul, empate
- **Estrat√©gia:** Analisar frequ√™ncia, sequ√™ncias e altern√¢ncia do hist√≥rico completo.

### üÉè Football Studio
- Hist√≥rico: direita ‚Üí esquerda (mais recente √† esquerda)
- Cores v√°lidas: vermelho, azul, empate
- **Estrat√©gia:** Analisar frequ√™ncia, sequ√™ncias e altern√¢ncia do hist√≥rico completo.

### ‚úàÔ∏è Aviator
- Multiplicadores: Vela Azul/Baixo (at√© 2x), Vela Roxa/M√©dio (2.1x a 9.9x), Vela Rosa/Alto (10x+)
- **Estrat√©gia:** Analisar padr√µes de multiplicadores e tend√™ncias.

### üéØ Roleta Europeia
- **Estrat√©gia:** Calcular salto m√©dio entre casas e projetar pr√≥xima √°rea no disco.

### üé∞ Slots
- Reconhecer apelidos populares: Tigrinho ‚Üí Fortune Tiger, Tourinho ‚Üí Fortune Ox, etc.
- **Estrat√©gia:** Explicar RTP, ciclos e orientar sobre gest√£o de banca.

## üìå Regras

### ‚úÖ Sempre
- SEMPRE Realizar **nova an√°lise estat√≠stica completa** (frequ√™ncia, sequ√™ncias, altern√¢ncia).
- SEMPRE Gerar **sugest√£o in√©dita** seguindo a estrutura de 3 frases.
- SEMPRE Usar linguagem leve, natural e variada.
- SEMPRE Tratar empate como parte da estrat√©gia.

### ‚ùå Nunca
- NUNCA repetir mensagens ou explica√ß√µes.
- NUNCA Garantir acertos ou prometer ganhos.
- NUNCA Pressionar o usu√°rio a continuar jogando.
- **NUNCA falar para o usu√°rio "apostar" explicitamente.** Use condicionais e frases sugestivas.
- **NUNCA repetir o hist√≥rico exato fornecido pelo usu√°rio na resposta.**

**Condicionais e Linguagem Sugestiva:** Use linguagem condicional (ex: "podem aparecer", "vamos ficar de olho", "a tend√™ncia parece ser", "que tal considerarmos", "parece uma possibilidade").

**RealsBet √© entretenimento com estrat√©gia. Proibido para menores de 18 anos. Jogue com responsabilidade.**`,
                            voice: 'echo',
                            input_audio_format: 'pcm16',
                            output_audio_format: 'pcm16',
                            input_audio_transcription: {
                                model: 'whisper-1'
                            },
                            turn_detection: {
                                type: 'server_vad',
                                threshold: 0.6,
                                prefix_padding_ms: 200,
                                silence_duration_ms: 500
                            },
                            tools: [],
                            tool_choice: 'auto',
                            temperature: 0.8,
                            max_response_output_tokens: 4096
                        }
                    });
                    
                    resolve();
                });

                this.openaiWs.once('error', (error) => {
                    clearTimeout(timeout);
                    reject(error);
                });
            });

        } catch (error) {
            console.error(`‚ùå Erro ao inicializar sess√£o ${this.sessionId}:`, error);
            throw error;
        }
    }

    setupOpenAIWebSocketHandlers() {
        this.openaiWs.on('message', (data) => {
            try {
                const message = JSON.parse(data.toString());
                
                // Log de eventos importantes e rastrear dados
                if (message.type === 'session.created') {
                    console.log(`üéâ Sess√£o criada: ${message.session.id}`);
                    this.sessionData.addMessage('system', 'Sess√£o criada');
                } else if (message.type === 'error') {
                    console.error(`‚ùå Erro da OpenAI:`, message.error);
                    this.sessionData.addMessage('error', `Erro: ${message.error.message}`);
                } else if (message.type === 'response.audio.delta') {
                    // √Åudio recebido da OpenAI - repassar para o cliente
                    if (this.clientWs && this.clientWs.readyState === WebSocket.OPEN) {
                        this.clientWs.send(JSON.stringify({
                            type: 'audio_delta',
                            audio: message.delta
                        }));
                    }
                    // Rastrear √°udio de sa√≠da
                    this.sessionData.addRecording(message.delta, 'assistant', 0.1); // Estimativa de 0.1s por delta
                    this.sessionData.audioOutputDuration += 0.1;
                } else if (message.type === 'input_audio_buffer.speech_started') {
                    console.log(`üé§ Fala detectada na sess√£o ${this.sessionId}`);
                    this.lastSpeechDetection = Date.now();
                    this.sessionData.addMessage('system', 'Fala detectada');
                    
                    // Se a IA estiver respondendo, cancelar para evitar sobreposi√ß√£o
                    if (this.isAIResponding) {
                        console.log(`‚ö° Cancelando resposta da IA devido a nova fala do usu√°rio`);
                        this.sendToOpenAI({
                            type: 'response.cancel'
                        });
                        this.isAIResponding = false;
                    }
                } else if (message.type === 'input_audio_buffer.speech_stopped') {
                    console.log(`üîá Fim da fala na sess√£o ${this.sessionId}`);
                    this.sessionData.addMessage('system', 'Fim da fala');
                } else if (message.type === 'response.audio.done') {
                    this.isAIResponding = false;
                } else if (message.type === 'response.created') {
                    this.isAIResponding = true;
                    this.sessionData.outputTokens += 10; // Estimativa
                } else if (message.type === 'conversation.item.input_audio_transcription.completed') {
                    // Rastrear transcri√ß√£o do usu√°rio
                    if (message.transcript) {
                        this.sessionData.addTranscription(message.transcript, 'user');
                        this.sessionData.inputTokens += Math.ceil(message.transcript.length / 4); // Estimativa de tokens
                    }
                } else if (message.type === 'response.audio_transcript.delta') {
                    // Rastrear transcri√ß√£o da IA
                    if (message.delta) {
                        this.sessionData.addTranscription(message.delta, 'assistant');
                    }
                }

                // Repassar todas as mensagens para o cliente (exceto √°udio que j√° foi tratado)
                if (this.clientWs && this.clientWs.readyState === WebSocket.OPEN && message.type !== 'response.audio.delta') {
                    this.clientWs.send(JSON.stringify({
                        type: 'openai_event',
                        event: message
                    }));
                }

            } catch (error) {
                console.error('‚ùå Erro ao processar mensagem da OpenAI:', error);
            }
        });

        this.openaiWs.on('close', (code, reason) => {
            console.log(`üîå Conex√£o OpenAI fechada: ${code} - ${reason}`);
            this.isConnected = false;
            
            if (this.clientWs && this.clientWs.readyState === WebSocket.OPEN) {
                this.clientWs.send(JSON.stringify({
                    type: 'connection_closed',
                    reason: 'OpenAI connection closed'
                }));
            }
        });

        this.openaiWs.on('error', (error) => {
            console.error(`‚ùå Erro na conex√£o OpenAI:`, error);
            if (this.clientWs && this.clientWs.readyState === WebSocket.OPEN) {
                this.clientWs.send(JSON.stringify({
                    type: 'error',
                    message: 'Erro na conex√£o com OpenAI'
                }));
            }
        });
    }

    setupClientWebSocketHandlers() {
        this.clientWs.on('message', (data) => {
            try {
                const message = JSON.parse(data.toString());
                
                if (message.type === 'audio_data') {
                    // √Åudio do cliente - enviar para OpenAI
                    this.sendToOpenAI({
                        type: 'input_audio_buffer.append',
                        audio: message.audio
                    });
                    // Rastrear √°udio de entrada
                    this.sessionData.addRecording(message.audio, 'user', 0.1); // Estimativa de 0.1s por chunk
                    this.sessionData.audioInputDuration += 0.1;
                } else if (message.type === 'commit_audio') {
                    // Cliente terminou de enviar √°udio
                    this.sendToOpenAI({
                        type: 'input_audio_buffer.commit'
                    });
                } else if (message.type === 'cancel_response') {
                    // Cancelar resposta atual
                    this.sendToOpenAI({
                        type: 'response.cancel'
                    });
                    this.sessionData.addMessage('system', 'Resposta cancelada');
                }

            } catch (error) {
                console.error('‚ùå Erro ao processar mensagem do cliente:', error);
            }
        });

        this.clientWs.on('close', () => {
            console.log(`üîå Cliente desconectado: ${this.sessionId}`);
            this.cleanup();
        });

        this.clientWs.on('error', (error) => {
            console.error(`‚ùå Erro na conex√£o do cliente:`, error);
        });
    }

    sendToOpenAI(message) {
        if (this.openaiWs && this.openaiWs.readyState === WebSocket.OPEN) {
            this.openaiWs.send(JSON.stringify(message));
        } else {
            console.warn('‚ö†Ô∏è Tentativa de enviar mensagem para OpenAI com conex√£o fechada');
        }
    }

    cleanup() {
        if (this.openaiWs) {
            this.openaiWs.close();
        }
        
        // Finalizar dados da sess√£o
        this.sessionData.endTime = new Date();
        this.sessionData.addMessage('system', 'Sess√£o encerrada');
        
        // Log do resumo da sess√£o
        const summary = this.sessionData.getSessionSummary();
        console.log(`üìä Resumo da sess√£o ${this.sessionId}:`, {
            dura√ß√£o: `${summary.duration}s`,
            custo: `$${summary.totalCost.toFixed(6)}`,
            mensagens: summary.messagesCount,
            transcri√ß√µes: summary.transcriptionsCount,
            grava√ß√µes: summary.recordingsCount
        });
        
        activeSessions.delete(this.sessionId);
        console.log(`üßπ Sess√£o limpa: ${this.sessionId}`);
    }
}

// Criar servidor HTTP
const server = app.listen(PORT, '0.0.0.0', () => {
    console.log(`üöÄ Servidor rodando em http://localhost:${PORT}`);
    console.log(`üìÅ Arquivos est√°ticos servidos de: ${path.join(__dirname, 'public')}`);
});

// Criar servidor WebSocket
const wss = new WebSocket.Server({ server });

wss.on('connection', async (ws, req) => {
    const sessionId = uuidv4();
    console.log(`üîó Nova conex√£o WebSocket: ${sessionId}`);

    try {
        // Criar e inicializar sess√£o OpenAI
        const session = new OpenAIRealtimeSession(sessionId);
        activeSessions.set(sessionId, session);

        await session.initialize(ws);

        // Enviar confirma√ß√£o de conex√£o para o cliente
        ws.send(JSON.stringify({
            type: 'connection_established',
            sessionId: sessionId,
            message: 'Conectado com sucesso √† OpenAI Realtime API'
        }));

    } catch (error) {
        console.error(`‚ùå Erro ao estabelecer sess√£o ${sessionId}:`, error);
        
        ws.send(JSON.stringify({
            type: 'connection_error',
            message: 'Erro ao conectar com OpenAI: ' + error.message
        }));
        
        ws.close();
        activeSessions.delete(sessionId);
    }
});

// Rota de status da API
app.get('/api/status', (req, res) => {
    res.json({
        status: 'online',
        activeSessions: activeSessions.size,
        timestamp: new Date().toISOString(),
        model: OPENAI_REALTIME_MODEL
    });
});

// Rota para obter dados da sess√£o
app.get('/api/session/:sessionId', (req, res) => {
    const { sessionId } = req.params;
    const sessionData = sessionDataStore.get(sessionId);
    
    if (!sessionData) {
        return res.status(404).json({ error: 'Sess√£o n√£o encontrada' });
    }
    
    res.json(sessionData.getSessionSummary());
});

// Rota para obter transcri√ß√µes da sess√£o
app.get('/api/session/:sessionId/transcriptions', (req, res) => {
    const { sessionId } = req.params;
    const sessionData = sessionDataStore.get(sessionId);
    
    if (!sessionData) {
        return res.status(404).json({ error: 'Sess√£o n√£o encontrada' });
    }
    
    res.json({
        sessionId,
        transcriptions: sessionData.transcriptions,
        count: sessionData.transcriptions.length
    });
});

// Rota para obter grava√ß√µes da sess√£o
app.get('/api/session/:sessionId/recordings', (req, res) => {
    const { sessionId } = req.params;
    const sessionData = sessionDataStore.get(sessionId);
    
    if (!sessionData) {
        return res.status(404).json({ error: 'Sess√£o n√£o encontrada' });
    }
    
    res.json({
        sessionId,
        recordings: sessionData.recordings,
        count: sessionData.recordings.length,
        totalInputDuration: sessionData.audioInputDuration,
        totalOutputDuration: sessionData.audioOutputDuration
    });
});

// Rota para obter custos da sess√£o
app.get('/api/session/:sessionId/costs', (req, res) => {
    const { sessionId } = req.params;
    const sessionData = sessionDataStore.get(sessionId);
    
    if (!sessionData) {
        return res.status(404).json({ error: 'Sess√£o n√£o encontrada' });
    }
    
    const cost = sessionData.calculateCost();
    res.json({
        sessionId,
        totalCost: cost,
        inputTokens: sessionData.inputTokens,
        outputTokens: sessionData.outputTokens,
        audioInputDuration: sessionData.audioInputDuration,
        audioOutputDuration: sessionData.audioOutputDuration,
        breakdown: {
            tokenCost: (sessionData.inputTokens * 0.000006) + (sessionData.outputTokens * 0.000024),
            audioCost: (sessionData.audioInputDuration + sessionData.audioOutputDuration) * 0.000024
        }
    });
});

// Rota para listar todas as sess√µes
app.get('/api/sessions', (req, res) => {
    const sessions = Array.from(sessionDataStore.values()).map(session => session.getSessionSummary());
    res.json({
        sessions,
        count: sessions.length,
        totalCost: sessions.reduce((sum, session) => sum + session.totalCost, 0)
    });
});

// Rota principal
app.get('/', (req, res) => {
    res.sendFile(path.join(__dirname, 'public', 'index.html'));
});

// Tratamento de erros n√£o capturados
process.on('uncaughtException', (error) => {
    console.error('‚ùå Erro n√£o capturado:', error);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('‚ùå Promise rejeitada n√£o tratada:', reason);
});

// Limpeza ao encerrar o processo
process.on('SIGINT', () => {
    console.log('\nüõë Encerrando servidor...');
    
    // Fechar todas as sess√µes ativas
    activeSessions.forEach(session => {
        session.cleanup();
    });
    
    server.close(() => {
        console.log('‚úÖ Servidor encerrado com sucesso');
        process.exit(0);
    });
});

console.log('üéØ Configura√ß√£o:');
console.log(`   - Modelo OpenAI: ${OPENAI_REALTIME_MODEL}`);
console.log(`   - Porta: ${PORT}`);
console.log(`   - Ambiente: ${process.env.NODE_ENV || 'development'}`);
console.log('üìù Logs ser√£o exibidos aqui...\n');

